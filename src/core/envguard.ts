import * as fs from 'fs';
import * as path from 'path';
import { EventEmitter } from 'events';
import { FileManager } from '../utils/file_manager';
import { EncryptionManager } from '../utils/encryption';
import { parseDotenvFile } from '../utils/parseDotenvFile';
import { TypeValidator } from '../validators/type-validator';
import { EnvSchema, EnvGuardOptions, EnvError, ParsedEnv } from '../types';

export class EnvGuard extends EventEmitter {
  private schema: EnvSchema;
  private options: Required<EnvGuardOptions>;
  private cachedEnv: ParsedEnv | null = null;
  private fileWatcher: fs.FSWatcher | null = null;
  private typeValidator: TypeValidator;
  private fileManager: FileManager;
  private encryptionManager: EncryptionManager | null = null;

  constructor(options: EnvGuardOptions) {
    super();

    this.schema = options.schema;
    this.options = {
      envPath: options.envPath || path.join(process.cwd(), '.env'),
      autoCreate: options.autoCreate ?? true,
      autoPopulate: options.autoPopulate ?? true,
      strict: options.strict ?? false,
      cache: options.cache ?? true,
      skipOsEnv: options.skipOsEnv ?? false,
      watch: options.watch ?? false,
      onError: options.onError || (() => { }),
      onWarning: options.onWarning || (() => { }),
      encrypt: options.encrypt ?? false,
      encryptionKey: options.encryptionKey || '',
      schema: options.schema,
    };

    this.typeValidator = new TypeValidator();
    this.fileManager = new FileManager(this.options.envPath);

    if (this.options.encrypt) {
      this.encryptionManager = new EncryptionManager(this.options.encryptionKey);
    }

    this.initialize();
  }

  private initialize(): void {
    // create .env file if not exists
    if (this.options.autoCreate && !this.fileManager.exists()) {
      this.createEnvFile();
    }

    // load environment variables
    this.loadEnv();

    // watch for changes in .env file
    if (this.options.watch) {
      this.watchEnvFile();
    }
  }

  private createEnvFile(): void {
    const content = this.generateEnvTemplate();
    this.fileManager.write(content);
    console.log(`‚úÖ Created ${this.options.envPath}`);
  }

  private generateEnvTemplate(): string {
    let content = '# Environment Variables\n';
    content += `# Generated by EnvGuard on ${new Date().toISOString()}\n\n`;

    const groups = this.groupFields();

    for (const [groupName, fields] of Object.entries(groups)) {
      content += `# ========== ${groupName.toUpperCase()} ==========\n`;

      for (const [key, config] of Object.entries(fields)) {
        if (config.description) {
          content += `# ${config.description}\n`;
        }
        if (config.example) {
          content += `# Example: ${key}=${config.example}\n`;
        }
        if (config.deprecated) {
          const msg = typeof config.deprecated === 'string' ? config.deprecated : 'This field is deprecated';
          content += `# ‚ö†Ô∏è  DEPRECATED: ${msg}\n`;
        }

        const value = config.default !== undefined ? config.default : '';
        content += `${key}=${value}\n\n`;
      }
    }

    return content;
  }

  private groupFields(): Record<string, EnvSchema> {
    const groups: Record<string, EnvSchema> = { 'General': {} };

    for (const [key, config] of Object.entries(this.schema)) {
      const group = config.group || 'General';
      if (!groups[group]) {
        groups[group] = {};
      }
      groups[group][key] = config;
    }

    return groups;
  }

  private loadEnv(): void {
    // load .env file
    const envContent = this.fileManager.read();
    const envVars = this.parseEnvFile(envContent);

    // merge with process.env
    Object.assign(process.env, envVars);

    // parse and validate environment variables
    const parsed = this.parse(this.options.skipOsEnv ? process.env : parseDotenvFile(process.env));

    if (this.options.cache) {
      this.cachedEnv = parsed;
    }
  }

  private parseEnvFile(content: string): Record<string, string> {
    const vars: Record<string, string> = {};
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;

      const match = trimmed.match(/^([A-Z_][A-Z0-9_]*)\s*=\s*(.*)$/i);
      if (match) {
        const [, key, value] = match;
        vars[key] = value.replace(/^["']|["']$/g, '');
      }
    }

    return vars;
  }

  private watchEnvFile(): void {
    this.fileWatcher = fs.watch(this.options.envPath, (eventType) => {
      if (eventType === 'change') {
        console.log('üîÑ .env file changed, reloading...');
        this.loadEnv();
        this.emit('reload', this.cachedEnv);
      }
    });
  }

  public parse(env: Record<string, any> = this.options.skipOsEnv ? process.env : parseDotenvFile(process.env)): ParsedEnv {
    const errors: EnvError[] = [];
    const warnings: string[] = [];
    const parsed: ParsedEnv = {};

    // loop for missing required fields
    for (const [key, config] of Object.entries(this.schema)) {
      const rawValue = env[key];

      // warning for deprecated fields
      if (config.deprecated && rawValue !== undefined) {
        const msg = typeof config.deprecated === 'string' ? config.deprecated : 'This field is deprecated';
        warnings.push(`‚ö†Ô∏è  ${key}: ${msg}`);
      }

      // check for missing required fields
      if (config.required && (rawValue === undefined || rawValue === '')) {
        errors.push({
          field: key,
          message: `Required field is missing`,
          type: 'missing',
        });
        continue;
      }

      // use default value if not provided
      let value = rawValue !== undefined && rawValue !== '' ? rawValue : config.default;

      if (value === undefined) {
        continue;
      }

      // parse and validate value based on type
      try {
        value = this.typeValidator.validate(key, value, config);

        // apply custom transformation
        if (config.transform) {
          value = config.transform(value);
        }

        // apply custom validation
        if (config.validate) {
          const validationResult = config.validate(value);
          if (validationResult !== true) {
            throw new Error(typeof validationResult === 'string' ? validationResult : 'Validation failed');
          }
        }

        // decrypt sensitive data
        if (config.sensitive && this.encryptionManager && typeof value === 'string') {
          try {
            value = this.encryptionManager.decrypt(value);
          } catch {

          }
        }

        parsed[key] = value;
      } catch (error: any) {
        errors.push({
          field: key,
          message: error.message,
          type: 'invalid',
        });
      }
    }

    // strict mode: check for unknown variables
    if (this.options.strict) {
      const schemaKeys = new Set(Object.keys(this.schema));
      for (const key of Object.keys(env)) {
        if (!schemaKeys.has(key) && key !== '_' && !key.startsWith('npm_')) {
          warnings.push(`Unknown environment variable: ${key}`);
        }
      }
    }

    // handle errors
    if (errors.length > 0) {
      this.options.onError(errors);
      const errorMsg = errors.map(e => `  - ${e.field}: ${e.message}`).join('\n');
      // throw new Error(`Environment validation failed:\n${errorMsg}`);
    }

    // handle warnings
    if (warnings.length > 0) {
      this.options.onWarning(warnings);
      warnings.forEach(w => console.warn(w));
    }

    return parsed;
  }

  public get<T = any>(key: string): T {
    if (this.options.cache && this.cachedEnv) {
      return this.cachedEnv[key] as T;
    }
    return this.parse()[key] as T;
  }

  public getAll(): ParsedEnv {
    if (this.options.cache && this.cachedEnv) {
      return { ...this.cachedEnv };
    }
    return this.parse();
  }

  public update(key: string, value: any): void {
    const config = this.schema[key];
    if (!config) {
      throw new Error(`Unknown environment variable: ${key}`);
    }

    // encrypt sensitive data
    if (config.sensitive && this.encryptionManager) {
      value = this.encryptionManager.encrypt(value);
    }

    // update process.env
    process.env[key] = String(value);

    // update .env file
    this.fileManager.updateKey(key, value);

    // update cache
    if (this.options.cache) {
      this.cachedEnv = this.parse();
    }

    this.emit('update', key, value);
  }

  public generateTypes(outputPath: string): void {
    let types = '// Auto-generated by EnvGuard\n';
    types += '// Do not edit this file manually\n\n';
    types += 'export interface Env {\n';

    for (const [key, config] of Object.entries(this.schema)) {
      if (config.description) {
        types += `  /** ${config.description} */\n`;
      }

      let tsType = 'string';
      switch (config.type) {
        case 'number':
        case 'port':
          tsType = 'number';
          break;
        case 'boolean':
          tsType = 'boolean';
          break;
        case 'enum':
          tsType = config.enum ? config.enum.map(v => `'${v}'`).join(' | ') : 'string';
          break;
        case 'json':
          tsType = 'any';
          break;
      }

      const optional = !config.required ? '?' : '';
      types += `  ${key}${optional}: ${tsType};\n`;
    }

    types += '}\n\n';
    types += 'declare global {\n';
    types += '  namespace NodeJS {\n';
    types += '    interface ProcessEnv extends Env {}\n';
    types += '  }\n';
    types += '}\n\n';
    types += 'export {};\n';

    fs.writeFileSync(outputPath, types);
    console.log(`‚úÖ Types generated at ${outputPath}`);
  }

  public destroy(): void {
    if (this.fileWatcher) {
      this.fileWatcher.close();
    }
    this.removeAllListeners();
  }
}

export function createEnvGuard(options: EnvGuardOptions): EnvGuard {
  return new EnvGuard(options);
}